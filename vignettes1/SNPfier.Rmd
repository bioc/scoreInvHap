---
title: "Call inversions with snpfier"
subtitle: "Carlos Ruiz, Juan R. Gonzalez"
author: |
  | Institute for Global Health (ISGlobal), Barcelona, Spain
  | Bioinformatics Research Group in Epidemiolgy (BRGE)
  | (<http://www.creal.cat/brge.htm>)
date: "`r Sys.Date()`"
package: "`r pkg_ver('snpfier')`"
output: 
  BiocStyle::html_document:
    number_sections: true
    toc: yes
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Call haplotype inversions with snpfier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=TRUE)
```

# Introduction

`r Rpackage("snpfier")` infers haplotype inversion's status of a set of samples using SNP data. This method computes a similarity score between the sample SNPs in your cohort using the information obtained from a reference of inverted and standard individuals where the haplotypes are known. These scores are then used to infer the haplotype inversion status by applying a Linear Discriminant Analysis (LDA) model. There are other approaches to perform this task such us [inveRsion](https://bioconductor.org/packages/release/bioc/html/inveRsion.html), [invClust](http://nar.oxfordjournals.org/content/early/2015/02/05/nar.gkv073.full) or [PFIDO](https://github.com/MaxSalm/pfido) that are based on multivariate clustering procedures. Using these methods have several limitation when:

* __analizing limited or moderate number of samples__. Clustering methods require to have large number of samples to perform clustering to properly discriminate haplotype inversion status. In particular, calling of a single sample cannot be performed without having a reference data. 
* __analyzing data from different SNP arrays__ .  `r Rpackage("PFIDO")` and `r Rpackage("invClust")` may provide different answers depending on which array is used (i.e., Illumina 1M, Affy 6.0, ...) since dfferent coverage may lead to perform the calling using different number of SNPs of a given inverted region. 
* __combining calling from different SNP arrrays__ . `r Rpackage("invClust")` and `r Rpackage("PFIDO")` clasify each individual as homocygous normal, heterozygous or homocigous inverted depending on cluster frequency. In those cases where inversion with haplotype frequency is close to 50%, both methods may have problems to determine which is the reference haplotype. Performing calling in different cohort of samples may lead to wrong results when combining data from different studies.

`r Rpackage("snpfier")` overcomes these difficulties by using a set of reference genotypes that has been used to properly characterize the inversion of interest. Genomic information such as linkage desequillibrium (R^2^) and hetgerozygous sequence has been determined for the region of interest (ROI). The LDA models has been extensively trained by using large real dataset from different ethnicities. These models are used to predict haplotype inversion genotypes in samples of interest.  

# Inversion characterization

The package can be loaded by typing:

```{r, load_package}
library(snpfier)
```

Calling procedure requires four objects that characterize the inversion of interest: the reference genotypes, the SNPs R^2^, the heterozygous reference and the LDA models. `r Rpackage("snpfier")`  contains these required objects for six well known genomic inversions: 2q13 (ROIno.2.13), 3q29 (ROIno.3.2), 7q11.21 (ROIno.7.10), 8p23 (ROIno.8.3), 16p11.2 (ROIno.16.13) and 17q21.31 (ROIno.17.16). These required obejects of this 6 inversions are available in the package. Each inversion is annotated using the ROI numbers used in [Sander's paper](http://genome.cshlp.org/content/early/2016/10/07/gr.201160.115.abstract). The objects have been created using VCF phase 3 data of [1000 Genomes Project](http://www.internationalgenome.org/). The code used to generate them can be found in the /inst/scripts folder of the package. This code can be modify to create the required files of any other inversion of interest. 

## Reference genotypes

As previously stated, the method needs, for each SNP located into the inversion region, the frequency of genotypes in the homozygous standard, heterozygous and homozygous inverted populations. This information is encoded in an object called `Refs` that can be loaded by typing:

```{r, load data}
data("Refs")
names(Refs)
```

Each element of this list is a reference for one of the 6 available inversions. For instance, the reference of inversion ROIno.8.3 can be obtained by executing: 

```{r, Refs}
ref <- Refs$ROIno.8.3
class(ref)
ref[1:2]
```

This object is a list of matrices containing the frequency of each genotype (columns) in each inversion genotype (rows). Each component is named with the SNP id contained in the ROI. Notice that the alleles of the heteryzogous genotype are alphabetically ordered.

## SNPs R^2^ with inversion

The second object required is a vector containing the R^2^ between the inversion status and the SNPs genotypes. The SNPs with higher R^2^ will have more influence when computing the similarity score. We have formatted this object as a numeric vector, named with the SNPs ids. We have included these values in the object called `SNPsR2`: 

```{r, SNPsR2}
data("SNPsR2")
names(SNPsR2)
R2s <- SNPsR2$ROIno.8.3
head(R2s)
```

`SNPsR2` is also a list that contains the R^2^ of the 6 available inversions. Each element of this list is a numeric vector with the R^2^. 

## Heterozygous reference

The heterozygous reference object contains the heterozygous genotypes of the SNPs included in the references. This information is used to ensure that input SNPs have the same alleles than those used in the reference. This information is included in the object called `hetRefs` that can be inspect by typing:

```{r, hetRefs}
data("hetRefs")
names(hetRefs)
hRefs <- hetRefs$ROIno.8.3
head(hRefs)
```

`hRefs` is a character vector contaning the heterozygous genotypes of the SNPs used as references in the ROI. It should be noticed that, in the heterozygous genotype, the alleles MUST BE ordered alphabetically.

## LDA models 

LDA models have been trained in CEU samples and are used to infer the inversion status in a given cohort of individuals. Briefly, these predictive models are built by using information from similarity scores. These scores measures how similar is each haplotype with the reference ones (inverted and non-inverted). The coefficients of LDA models that are used to predict the haplotypes in new samples have been estimated for the 6 available inversions in CEU samples using `r Rpackage("MASS")`. This information is stored in a list called ``ldamodels`` tha can be inspect by: 


```{r, LDA models}
library(MASS)
data("ldamodels")
names(ldamodels)
mod <- ldamodels$ROIno.8.3
mod
```

# Running snpfier 

`r Rpackage("snpfier")` works with data in the plink format. Therefore, the input is a list with at least two elements:

* genotypes: a SNPMatrix with individuals in rows and SNPs in columns
* map: a data.frame with the SNPs annotation. It *must* contain the columns *allele.1* and *allele.2* with the alleles of the SNPs. 

We have included in the `r Rpackage("brgeDummyData")` package some SNPs to show `r Rpackage("snpfier")` capabilities. The object `snpsVCF` contains a subset of SNPs from the 1000 Genomes project. All these SNPs are from chromosome 8 and the individuals are from the European and African superpopulations:

```{r, Load SNPs, message=FALSE}
library(brgeDummyData)
data("snpsVCF")
names(snpsVCF)
snpsVCF$genotypes
head(snpsVCF$map)
```

The references that we have included in the package are only valid for european samples. Consequently, we will first select these samples prior to running the analysis. `samp_pop` is vector with the ancestry of each samples and can be found in `r Rpackage("brgeDummyData")`:

```{r, filter EUR}
data("samp_pop")
EURsamps <- rownames(samp_pop[samp_pop$superpop == "EUR", ])
EUR <- snpsVCF
EUR$genotypes <- EUR$genotypes[EURsamps, ]
```

Now we are ready to classify the samples. The function `classifierPipeline` needs five objects: the genotypes and their annotation (`SNPlist`) and the four objects that characterize the inversion. `Refs` is the list of matrices with the frequency of each genotypes in each inversion population. `SNPsR2` is the numeric vector with the SNPs R^2^. `hetRefs` is the vector with the heterozygous genotypes of the SNPs and `ldamodel` is the LDA model used to classify the individuals. We will get the inversion status of the inversion ROIno.8.3:  

```{r, classify EUR}
res <- classifierPipeline(SNPlist = EUR, SNPsR2 = SNPsR2$ROIno.8.3, hetRefs = hetRefs, 
                          Refs = Refs$ROIno.8.3, ldamodel = ldamodels$ROIno.8.3)
res
```

The results of `classifierPipeline` are encapsulated in a `snpfieres` object. This object contains the classification of the samples, the certainty of the classification and the simmilarity scores. We can get this data with the following functions: 

```{r, snpfier results}
# Get classification
head(classification(res))
# Get certainty
head(certainty(res))
# Get scores
head(scores(res))
```

To have a quick overview of the classification, we can plot the simmilarity scores with the samples classification. We can easily do so by using the `plot` function to the object:

```{r, plot 1}
plot(res)
```

This function relies on the `plot` from base package. Therefore, we can modify the plot using the same arguments of the base function. Now, we will change the symbol plot depending on the certainty of the classification. Samples with a high certainty will have a full point and samples with low certainty an empty point. We will also add a title:

```{r, plot 2}
plot(res, pch = ifelse(certainty(res) > 0.99999, 16, 1), main = "Certain classification")
```

# Advanced features

There are two additional parameters of `classifierPipeline` than can reduce its computing time: `R2` and `mc.cores`. `R2` indicates the minimum R^2^ that a SNP should have with the inversion to be included in the score. By default, only SNPs with a R^2^ equal or higher than 0.3 are included in the computation. `mc.cores` allows to parallelize the computation of the score. However, given that it relies on `mclapply` function of `r Rpackage("parallel")` package, this option is not available in Windows. 

In the next lines, we will show what happens when the haplotype references do not agree with the haplotypes present in our samples. As mentioned before, the references included in the package have been created from European samples and might not be right for other superpopulations. We will run the same analysis but including the African samples. To speed up the process, we will select only those SNPs with a R^2^ higher than 0.4 and we will use 4 cores:

```{r, classify all}
resAll <- classifierPipeline(SNPlist = snpsVCF, SNPsR2 = SNPsR2$ROIno.8.3, hetRefs = hetRefs, 
                          Refs = Refs$ROIno.8.3, ldamodel = ldamodels$ROIno.8.3, 
                          R2 = 0.4, mc.cores = 4)
resAll
```

At first sight, the new results are not very different from the previous ones. The mean certainty has only slightly fallen (from 0.998 to 0.982). The main difference is that the inversion frequency has drop 10 points (from 42% to 33%). However, if we can see the problems if we plot the results:

```{r, plot all}
plot(resAll)
```

Now, there is a big cloud of points in the center of the plot. We can change the symbol to identify the ancestry of the samples:

```{r, plot all 2}
plot(resAll, pch = ifelse(rownames(snpsVCF$genotypes) %in% EURsamps, 16, 17), main = "Ancestry")
```

In this plot, European samples are represented by a circle and African by a triangle. The points in the center of the plot are from African samples that are not properly classified. 

When the haplotypes present in the samples agree with the references, we expect the samples to be in the corners of the plots. This means that the samples are very similar to one of the references (homozygous) or they are totally different (heterozygous). However, when the samples have other haplotypes, the samples will match to one reference in some SNPs and to the other reference in other. Then, the similarity scores have medium values and the samples tend to be clustered in the middle of the plot. We can take profit of this behaviour to extract biological knowledge. For instance, we can study if the haplotype structure is conserved in cancer cells, or to examine similarities and differences between human populations.
