---
title: "Call inversions with SNPfier"
subtitle: "Carlos Ruiz, Juan R. González"
author: |
  | Institute for Global Health (ISGlobal), Barcelona, Spain
  | Bioinformatics Research Group in Epidemiolgy (BRGE)
  | (<http://www.creal.cat/brge.htm>)
date: "`r Sys.Date()`"
package: "`r pkg_ver('snpfier')`"
output: 
  BiocStyle::html_document:
    number_sections: true
    toc: yes
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Call inversions with SNPfier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

`r Rpackage("snpfier")` infers haplotype inversion's status of a set of samples using SNP data. This method computes a similarity score between the sample SNPs and a reference of inverted and standard samples. The inversion status is infered by applying a Linear Discriminant Analysis (LDA) model to the similarity scores.

# Inversion characterization

`r Rpackage("SNPfier")` needs four objects that characterize the inversion: the references genotypes, the SNPs R^2^, the heterozygous reference and the LDA models. In this package, we have included these objects for six genomic inversions (ROIno.2.13, ROIno.3.2, ROIno.7.10, ROIno.8.3,  ROIno.16.13 and ROIno.17.16). These objects have been created using VCF phase 3 data of 1000 Genomes Project. The code used to generate them can be found in the /inst/scripts folder of the package. 

## References

The algorithm needs, for each SNP, the frequency of each genotype in the homozygous standard, heterozygous and homozygous inverted populations. This information can be found in the `Refs` object:

```{r, load data}
library(SNPfier)
data("Refs")
names(Refs)
```

`Refs` is a list that contains the references of the six inversions characterized. Each element of this list is a reference for a different inversion. We can take a look to the reference of inversion ROIno.8.3: 

```{r, Refs}
ref <- Refs$ROIno.8.3
class(ref)
ref[1:2]
```

The reference is a list of matrices containing the frequency of each genotype in each inversion population. It should be noticed that each matrix is named using the SNP name and that the genotypes are placed on columns and the haplotypes in rows. Another important fact is that the heteryzogous genotype has the alleles ordered alphabetically.

## SNPs R^2^

The second object required is the R^2^ between the inversion status and the SNPs genotypes. The SNPs with a higher R^2^ are more weighted in the similarity score. We have formatted this object as a numeric vector, named with the SNPs ids. We have included these values in the object `SNPsR2`: 

```{r, SNPsR2}
data("SNPsR2")
names(SNPsR2)
R2s <- SNPsR2$ROIno.8.3
head(R2s)
```

As with the references, `SNPsR2` is a list that contains the R^2^ of the six inversions. Each element of this list is a numeric vector with the R^2^. 

## Heterozygous reference

The heterozygous reference contains the heterozygous genotypes of the SNPs included in the references. This information is required to ensure that input SNPs have the same alleles than those used in the references. This information is included in the `hetRefs` object:

```{r, hetRefs}
data("hetRefs")
head(hetRefs)
```

Given that this information is not specific of each inversion, `hetRefs` is a character vector contaning the heterozygous genotypes of all the SNPs of the references. It should be noticed that, in the heterozygous genotype, the alleles are ordered alphabetically.

## LDA models 

LDA models are used to infer the inversion status from the similarity scores. We have included the LDA models for the six inversions in `ldamodels`. We need the `r Rpackage("MASS")` library to visualize this object: 

```{r, LDA models}
library(MASS)
data("ldamodels")
names(ldamodels)
lda <- ldamodels$ROIno.8.3
lda
```

# Running SNPfier 

`r Rpackage("SNPfier")` works with data in the plink format. Therefore, the input is a list with at least two elements:

* genotypes: a SNPMatrix with individuals in rows and SNPs in columns
* map: a data.frame with the SNPs annotation. It *must* contain the columns *allele.1* and *allele.2* with the alleles of the SNPs. 

We have included in the `r Rpackage("brgeDummyData")` package some SNPs to show `r Rpackage("SNPfier")` capabilities. The object `snpsVCF` contains a subset of SNPs from the 1000 Genomes project. All these SNPs are from chromosome 8 and the individuals are from the European and African superpopulations:

```{r, Load SNPs, message=FALSE}
library(brgeDummyData)
data("snpsVCF")
names(snpsVCF)
snpsVCF$genotypes
head(snpsVCF$map)
```

The references that we have included in the package are only valid for european samples. Consequently, we will first select these samples prior to running the analysis. `samp_pop` is vector with the ancestry of each samples and can be found in `r Rpackage("brgeDummyData")`:

```{r, filter EUR}
data("samp_pop")
EURsamps <- rownames(samp_pop[samp_pop$superpop == "EUR", ])
EUR <- snpsVCF
EUR$genotypes <- EUR$genotypes[EURsamps, ]
```

Now we are ready to classify the samples. The function `classifierPipeline` needs five objects: the genotypes and their annotation (`SNPlist`) and the four objects that characterize the inversion. `Refs` is the list of matrices with the frequency of each genotypes in each inversion population. `SNPsR2` is the numeric vector with the SNPs R^2^. `hetRefs` is the vector with the heterozygous genotypes of the SNPs and `ldamodel` is the LDA model used to classify the individuals. We will get the inversion status of the inversion ROIno.8.3:  

```{r, classify EUR}
res <- classifierPipeline(SNPlist = EUR, SNPsR2 = SNPsR2$ROIno.8.3, hetRefs = hetRefs, 
                          Refs = Refs$ROIno.8.3, ldamodel = ldamodels$ROIno.8.3)
res
```

The results of `classifierPipeline` are encapsulated in a `SNPfieRes` object. This object contains the classification of the samples, the certainty of the classification and the simmilarity scores. We can get this data with the following functions: 

```{r, SNPfier results}
# Get classification
head(classification(res))
# Get certainty
head(certainty(res))
# Get scores
head(scores(res))
```

To have a quick overview of the classification, we can plot the simmilarity scores with the samples classification. We can easily do so by using the `plot` function to the object:

```{r, plot 1}
plot(res)
```

This function relies on the `plot` from base package. Therefore, we can modify the plot using the same arguments of the base function. Now, we will change the symbol plot depending on the certainty of the classification. Samples with a high certainty will have a full point and samples with low certainty an empty point. We will also add a title:

```{r, plot 2}
plot(res, pch = ifelse(certainty(res) > 0.99999, 16, 1), main = "Certain classification")
```

# Advanced features

There are two additional parameters of `classifierPipeline` than can reduce its computing time: `R2` and `mc.cores`. `R2` indicates the minimum R^2^ that a SNP should have with the inversion to be included in the score. By default, only SNPs with a R^2^ equal or higher than 0.3 are included in the computation. `mc.cores` allows to parallelize the computation of the score. However, given that it relies on `mclapply` function of `r Rpackage("parallel")` package, this option is not available in Windows. 

In the next lines, we will show what happens when the haplotype references do not agree with the haplotypes present in our samples. As mentioned before, the references included in the package have been created from European samples and might not be right for other superpopulations. We will run the same analysis but including the African samples. To speed up the process, we will select only those SNPs with a R^2^ higher than 0.4 and we will use 4 cores:

```{r, classify all}
resAll <- classifierPipeline(SNPlist = snpsVCF, SNPsR2 = SNPsR2$ROIno.8.3, hetRefs = hetRefs, 
                          Refs = Refs$ROIno.8.3, ldamodel = ldamodels$ROIno.8.3, 
                          R2 = 0.4, mc.cores = 4)
resAll
```

At first sight, the new results are not very different from the previous ones. The mean certainty has only slightly fallen (from 0.998 to 0.982). The main difference is that the inversion frequency has drop 10 points (from 42% to 33%). However, if we can see the problems if we plot the results:

```{r, plot all}
plot(resAll)
```

Now, there is a big cloud of points in the center of the plot. We can change the symbol to identify the ancestry of the samples:

```{r, plot all 2}
plot(resAll, pch = ifelse(rownames(snpsVCF$genotypes) %in% EURsamps, 16, 17), main = "Ancestry")
```

In this plot, European samples are represented by a circle and African by a triangle. The points in the center of the plot are from African samples that are not properly classified. 

When the haplotypes present in the samples agree with the references, we expect the samples to be in the corners of the plots. This means that the samples are very similar to one of the references (homozygous) or they are totally different (heterozygous). However, when the samples have other haplotypes, the samples will match to one reference in some SNPs and to the other reference in other. Then, the similarity scores have medium values and the samples tend to be clustered in the middle of the plot. We can take profit of this behaviour to extract biological knowledge. For instance, we can study if the haplotype structure is conserved in cancer cells, or to examine similarities and differences between human populations.
