---
title: "Call inversions with snpfier"
subtitle: "Carlos Ruiz, Juan R. Gonzalez"
author: |
  | Institute for Global Health (ISGlobal), Barcelona, Spain
  | Bioinformatics Research Group in Epidemiolgy (BRGE)
  | (<http://www.creal.cat/brge.htm>)
date: "`r Sys.Date()`"
package: "`r pkg_ver('snpfier')`"
output: 
  BiocStyle::html_document:
    number_sections: true
    toc: yes
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Call haplotype inversions with snpfier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

# Introduction

`r Rpackage("snpfier")` infers haplotype inversion's status of a set of samples using SNP data. This method computes a similarity score between the sample SNPs in your cohort and the reference haplotypes. Samples are classified into the haplotype having the highest score. There are other approaches to perform this task such us [inveRsion](https://bioconductor.org/packages/release/bioc/html/inveRsion.html), [invClust](http://nar.oxfordjournals.org/content/early/2015/02/05/nar.gkv073.full) or [PFIDO](https://github.com/MaxSalm/pfido) that are based on multivariate clustering procedures. However, these approaches may have several limitation that are addressed by using `r Rpackage("snpfier")`. These limitations include:

* __analizing limited or moderate number of samples__. Clustering methods require to have large number of samples to perform clustering to properly discriminate haplotype inversion status. In particular, calling of a single sample cannot be performed without having a reference data. 
* __analyzing data from different SNP arrays__.  `r Rpackage("PFIDO")` and `r Rpackage("invClust")` may provide different answers depending on which array is used (i.e., Illumina 1M, Affy 6.0, ...) since dfferent coverage may lead to perform the calling using different number of SNPs of a given inverted region. 
* __combining calling from different SNP arrrays__. `r Rpackage("invClust")` and `r Rpackage("PFIDO")` clasify each individual as homozygous normal, heterozygous or homozygous inverted depending on cluster frequency. In those cases where inversion with haplotype frequency is close to 50%, both methods may have problems to determine which is the reference haplotype. Performing calling in different cohort of samples may lead to wrong results when combining data from different studies.

`r Rpackage("snpfier")` overcomes these difficulties by using a set of reference genotypes that has been used to properly characterize the inversion of interest. Genomic information such as linkage desequillibrium (R^2^) and hetgerozygous sequence has been determined for each of the region of interest (ROI) and are used to create the score that discriminate the inversion status.  

# Inversion characterization

The package can be loaded by typing:

```{r, load_package}
library(snpfier)
```

Calling procedure requires three objects that characterize the inversion of interest: 

- the reference genotypes,
- the SNPs R^2^, and 
- the heterozygous reference. 

`r Rpackage("snpfier")` already contains these required objects of four inversions. Two of them are well known and characterized genomic inversions: 8p23 (ROIno.8.3) and 17q21.31 (ROIno.17.16). These inversions are annotated using the ROI numbers used in [Sander's paper](http://genome.cshlp.org/content/early/2016/10/07/gr.201160.115.abstract). We have also included two inversions that are described in [invFEST database](http://invfestdb.uab.cat/): 7p11.2 (HsInv0286) and Xq13.2 (HsInv0396). These objects have been created using VCF phase 3 data of [1000 Genomes Project](http://www.internationalgenome.org/). The code used to generate them can be found in the `/inst/scripts` folder of the package. This code can be modified to create the required files of any other inversion of interest. Required information of other inversions will be incorporated in the future when checked in our group or described in the literature. 

## Reference genotypes

As previously stated, the method uses the frequency of the SNP genotypes of each SNP located into the inversion region. This information is provided for he different haplotype populations. This information is encoded in an object called `Refs` that can be loaded by typing:

```{r, load data}
data("Refs")
names(Refs)
```

Each element of this list is a reference for one of the four available inversions. For instance, the reference of inversion ROIno.8.3 can be obtained by: 

```{r, Refs}
ref <- Refs$ROIno.8.3
class(ref)
ref[1:2]
```

This object is a list of matrices containing the frequency of each genotype (columns) in each inversion genotype (rows). Each component is named with the SNP id contained in the ROI. Notice that the alleles of the heteryzogous genotypes are alphabetically ordered.

## SNPs R^2^ with inversion

The second object required is a vector containing the R^2^ between the inversion status and the SNPs genotypes. The SNPs with higher R^2^ will have more influence when computing the similarity score. We have formatted this object as a numeric vector, named with the SNPs ids. This information is provided in the object called `SNPsR2`. This is a list that contains the R^2^ of the four available inversions. For instance, this information for the inversion ROIno.8.3 can be get by:

```{r, SNPsR2}
data("SNPsR2")
names(SNPsR2)
R2s <- SNPsR2$ROIno.8.3
head(R2s)
```


## Heterozygous reference

The last required information is the heterozygous genotypes of the SNPs included in the references. This information is used to ensure that input SNPs have the same coded alleles than those used in the reference. This information can be retrieve from the object called `hetRefs` that can be inspect by typing:

```{r, hetRefs}
data("hetRefs")
names(hetRefs)
hRefs <- hetRefs$ROIno.8.3
head(hRefs)
```

In that case, `hRefs` is a character vector contaning the heterozygous genotypes of the SNPs used as references in the ROI. It should be noticed that, in the heterozygous genotype, the alleles MUST BE ordered ALPHABETICALLY. 

# Running snpfier: calling inversions

`r Rpackage("snpfier")` deals with data either in a `SNPMatrix` or as Bioconductor `VCF` class. In the case of `SNPMatrix`, a list with two elements is required:

* genotypes: a SNPMatrix with individuals in rows and SNPs in columns
* map: a data.frame with the SNPs annotation. It *must* contain the columns *allele.1* and *allele.2* with the alleles of the SNPs. 

We can load our data from a ped file or from plink binary format (.bed, .bim) to a `SNPMatrix` using `r Biocpkg("snpStats")`:

```{r, eval=FALSE}
library(snpStats)

## From a bed 
snps <- read.plink("example.bed")

## From a pedfile
snps <- read.pedfile("example.ped", snps = "example.map")
```


In both cases, snps is a list containing the elements genotypes and map. This object can be passed to `r Rpackage("snpfier")` functions. 

We can load a vcf file into a `VCF` object using the `r Biocpkg("VariantAnnotation")`. We have included a small vcf in `r Rpackage("snpfier")` package to illustrate how to deal with this data. This file contains a subset of SNPs of 30 European individuals belonging to the 1000 Genomes project. All these SNPs are located at the region 7p11.2, the region annotated as HsInv0286 in the [Sander's paper](http://genome.cshlp.org/content/early/2016/10/07/gr.201160.115.abstract). This vcf file contains imputed data. We can load the vcf with the following code:

```{r, Load SNPs, message=FALSE}
library(VariantAnnotation)
vcf_file <- system.file("extdata", "example.vcf", package = "snpfier")
vcf <- readVcf(vcf_file, "hg19")
vcf
```

We can observe that the object `vcf` contains 380 SNPs and 30 samples. Now we are ready to classify the samples with regard to the inversion HsInv0286 by using the function `classifierPipeline`. This function requires four pieces of information:

- sample genotypes and their annotation (argument `SNPlist`),
- the list of matrices with the frequency of each genotypes in each inversion population (argument `Refs`),
- the numeric vector with the SNPs R^2^ (argument `SNPsR2`), and
- the vector with the heterozygous genotypes of the SNPs (argument `hetRefs`). 

The HsInv0286 inversion status of the 30 samples from 1000 genomes is obtained by:  

```{r, classify}
res <- classifierPipeline(SNPlist = vcf, SNPsR2 = SNPsR2$HsInv0286, 
                          hetRefs = hetRefs$HsInv0286, Refs = Refs$HsInv0286)
res
```

The results of `classifierPipeline` are encapsulated in a object of class `snpfieres`. This object contains the classification of the samples and the simmilarity scores. We can obtain this data with the following getters: 

```{r, snpfier results}
# Get classification
head(classification(res))
# Get scores
head(scores(res))
```

## Imputed data

When SNPs data are imputed, we obtain three different types of results: the best-guess, the dosage and the posterior probabilities. By default, `classifierPipeline` use the best-guess when computing the simmilarity scores. However, we can also use posterior probabilities setting the argument `imputed` to TRUE:

```{r, classify imputed}
res_imp <- classifierPipeline(SNPlist = vcf, SNPsR2 = SNPsR2$HsInv0286, hetRefs = hetRefs$HsInv0286, Refs = Refs$HsInv0286, imputed = TRUE)
res_imp
```

In this case, the samples were identically classified in both cases:

```{r, compare classifications}
table(PostProbs = classification(res_imp), 
      BestGuess = classification(res))
```

# Other features

There are two additional parameters of `classifierPipeline` than can reduce computing time: `R2` and `mc.cores`. `R2` indicates the minimum R^2^ that a SNP should have with the inversion to be included in the score. The less number of SNPs the less time it takes. By default, all SNPs are included in the computation. On the other hand, `mc.cores` allows to parallelize the computation of the score. However, given that it relies on `mclapply` function of `r Rpackage("parallel")` package, this option is not available in Windows. 

```{r}
sessionInfo()
```

